version: 2.1

orbs:
  terraform: circleci/terraform@3.1.0
  kubernetes: circleci/kubernetes@1.3.1

parameters:
  project-name:
    type: string
    default: "my-project"
  ruby-version:
    type: string
    default: "3.2.2"
  ruby-docker-distro:
    type: string
    default: "bullseye"
  bundler-version:
    description: "leave empty to use latest version"
    type: string
    default: ""
  db_adapter_for_build:
    description: "Use nulldb (activerecord-nulldb-adapter gem) for apps that needs to connect to database on initialization"
    type: string
    default: "postgresql"
  required-variables:
    type: string
    default: ""
  force_node:
    description: "any not empty value will force node to be installed in final docker image"
    type: string
    default: ""
  branches-for-envs:
    description: "List of branches matching environments for docker build and assets compilation"
    type: string
    default: "('master:production' 'staging')" # add any branch you want assets to be compiled on
  assets-buckets:
    type: string
    default: "()" # must match branches-for-envs size and order, if not filled, it will be (assets-bucket-production assets-bucket-staging)
  assets-bucket-staging:
    type: string
    default: ""
  assets-bucket-production:
    type: string
    default: ""
  ignored_cves:
    type: string
    default: ""
  build-and-deploy:
    type: boolean
    default: false
  deploy:
    type: boolean
    default: false
  tfvars:
    type: string
    default: ""
  workspace:
    type: string
    default: ""

jobs:
  build:
    working_directory: /tmp/app
    environment:
      DOCKER_REGISTRY: 396522184519.dkr.ecr.eu-west-1.amazonaws.com
    docker:
      - image: cimg/aws:2023.09
    steps:
      - checkout
      - setup_remote_docker
      - restore_cache:
          keys:
            - v1-{{ .Branch }}
          paths:
            - /tmp/caches/app.tar
      - run:
          name: Load Docker image layer cache
          command: |
            set +o pipefail
            docker load -i /tmp/caches/app.tar | true
      - run:
          name: Download shared Dockerfile and utils
          command: |
            git clone --depth 1 --branch test-ci-build-vic git@github.com:CapSens/circleCi-dynamic-config.git dynamic_configs
            cp -R dynamic_configs/.dockerdev ./
            rm -rf dynamic_configs
      - run:
          name: Determine rails environment to build
          command: |
            branches=<< pipeline.parameters.branches-for-envs >>

            for i in "${!branches[@]}"; do
              if [ $CIRCLE_BRANCH == ${branches[$i]%%:*} ]; then
                echo 'export RAILS_ENV=${branches[$i]##*:}' >> "$BASH_ENV"
                source "$BASH_ENV"
                echo 'RAILS_ENV defined as ${RAILS_ENV}'
                exit 0
              fi
            done

            echo 'no env found for branch ${CIRCLE_BRANCH}. Exiting...'
            exit 1

      - run:
          name: Build application Docker image
          command: |
            docker build -t "${DOCKER_REGISTRY}/<< pipeline.parameters.project-name >>:${CIRCLE_BRANCH}-${CIRCLE_SHA1}" \
              --build-arg DISTRO_NAME=<< pipeline.parameters.ruby-docker-distro >> \
              --build-arg RUBY_VERSION=<< pipeline.parameters.ruby-version >> \
              --build-arg BUNDLER_VERSION=<< pipeline.parameters.bundler-version >> \
              --build-arg DB_ADAPTER=<< pipeline.parameters.db_adapter_for_build >> \
              --build-arg FORCE_NODE=<< pipeline.parameters.force_node >> \
              --build-arg NODE_MAJOR=16 \
              --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} \
              --build-arg GITHUB_TOKEN_DEV=${GITHUB_TOKEN_DEV} \
              --build-arg REQUIRED_VARIABLES="<< pipeline.parameters.required-variables >>" \
              --file .dockerdev/Dockerfile \
              .
      - run:
          name: Extract assets from container and push to s3
          command: |
            branches=<< pipeline.parameters.branches-for-envs >>
            assetsBuckets=<< pipeline.parameters.assets-buckets >>
            if [ ${#assetsBuckets[@]} -eq 0 ]; then
              assetsBuckets=('<< pipeline.parameters.assets-bucket-production >>' '<< pipeline.parameters.assets-bucket-staging >>')
            fi

            for i in "${!branches[@]}"; do
              if [ $CIRCLE_BRANCH == ${branches[$i]%%:*} ]; then
                current_env=${branches[$i]##*:}
                bucket=${assetsBuckets[$i]}
              fi
            done

            if [[ -z "${bucket}" ]]; then
              echo "S3 bucket variable has not been set for env ${current_env}. Skipping assets compilation."
              exit 0
            else
              echo "ready to copy assets for env ${current_env} on assets bucket ${bucket}"

              id=$(docker create ${DOCKER_REGISTRY}/<< pipeline.parameters.project-name >>:${CIRCLE_BRANCH}-${CIRCLE_SHA1})

              docker cp $id:/home/my_user/app/public/assets public-assets && rm public-assets/manifest.json && \
              aws s3 cp ./public-assets s3://${bucket}/assets/ --recursive --acl public-read --cache-control max-age=${CACHE_MAX_AGE:-86400}

              if [[ `docker cp $id:/home/my_user/app/public/assets public-packs` ]]; then
                aws s3 cp ./public-packs s3://${bucket}/packs/ --recursive --acl public-read --cache-control max-age=${CACHE_MAX_AGE:-86400}
                aws s3 cp public/packs/ s3://${S3_ASSETS_BUCKET}/packs/ --recursive
              else
                echo "No public/packs directory, skipping packs upload."
              fi

              docker rm -v $id
            fi

      - run:
          name: Save Docker image layer cache
          command: |
            mkdir -p /tmp/caches
            docker save -o /tmp/caches/app.tar ${DOCKER_REGISTRY}/<< pipeline.parameters.project-name >>:${CIRCLE_BRANCH}-${CIRCLE_SHA1}
      - save_cache:
          key: v1-{{ .Branch }}-{{ epoch }}
          paths:
            - /tmp/caches/app.tar
      - run:
          name: Push application Docker image
          command: |
            # if [ "${CIRCLE_BRANCH}" == "master" ]; then
              rm -rf ~/.aws
              aws ecr get-login-password --region eu-west-1 | docker login --username AWS --password-stdin ${DOCKER_REGISTRY}
              docker push ${DOCKER_REGISTRY}/<< pipeline.parameters.project-name >>:${CIRCLE_BRANCH}-${CIRCLE_SHA1}
            # fi

  deploy:
    working_directory: ~/<< pipeline.parameters.project-name >>
    docker:
      - image: cimg/aws:2023.09
    steps:
      - checkout
      - terraform/install:
          arch: amd64
          os: linux
          terraform_version: 1.6.2
      - kubernetes/install-kubectl

      - run:
          name: Clone Terraform repository
          command: |
            git clone git@github.com:CapSens/terraform-infra.git terraform_infra

      - run:
          name: Create tfvars file
          command: |
            decrypted_tfvars=$(
              echo "<< pipeline.parameters.tfvars >>" |
              openssl enc -base64 -d -aes-256-cbc -salt -pass pass:${TERRAFORM_ENCRYPTION_KEY} -pbkdf2
            )
            cd terraform_infra
            mkdir -p live/rails_application
            tfvars_file="live/rails_application/tfvars/<< pipeline.parameters.workspace >>.tfvars"
            touch $tfvars_file
            echo "${decrypted_tfvars}" > $tfvars_file

      - run:
         name: Kubeconfig initialization
         command: |
           cd terraform_infra
           AWS_REGION=eu-west-1
           TERRAFORM_WORKSPACE=<< pipeline.parameters.workspace >>
           CLUSTER_ARN=arn:aws:eks:eu-west-1:396522184519:cluster/<< pipeline.parameters.workspace >>
           aws eks --region ${AWS_REGION} update-kubeconfig --name ${CLUSTER_ARN} && kubectl config rename-context ${CLUSTER_ARN} capsens-${TERRAFORM_WORKSPACE}

      - run:
          name: Terraform deploy
          command: |
            cd terraform_infra
            make init project=rails_application
            make new project=rails_application workspace=<< pipeline.parameters.workspace >> 2>/dev/null || true
            make apply project=rails_application workspace=<< pipeline.parameters.workspace >> extra_args=-auto-approve

workflows:
  version: 2

  workflow:
    when:
      and:
        - equal: [ false, << pipeline.parameters.build-and-deploy >> ]
        - equal: [ false, << pipeline.parameters.deploy >> ]

    jobs:
        - build:
            context:
              - GithubDev
              - Github
              - AWS_ECR

  build-and-deploy:
    when: << pipeline.parameters.build-and-deploy >>
    jobs:
        - build:
            context:
              - GithubDev
              - Github
              - AWS_ECR
        - deploy:
            requires:
              - build
            context:
              - GithubDev
              - Github
              - AWS_ECR

  deploy:
    when: << pipeline.parameters.deploy >>
    jobs:
        - deploy:
            context:
              - GithubDev
              - Github
              - AWS_ECR
